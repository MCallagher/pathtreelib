<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>pathtreelib &#8212; pathtreelib 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=039e1c02" />
    <script src="_static/documentation_options.js?v=01f34227"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <img alt="https://img.shields.io/badge/Version-Alpha-blue" src="https://img.shields.io/badge/Version-Alpha-blue" />
<img alt="https://img.shields.io/badge/License-MIT-blue" src="https://img.shields.io/badge/License-MIT-blue" />
<section id="pathtreelib">
<h1>pathtreelib<a class="headerlink" href="#pathtreelib" title="Link to this heading">¶</a></h1>
<p class="linemarker linemarker-9">The pathtreelib module aim to provide simple tools to analyse files and
directories. The files and directories are represented by nodes which are
organized in a tree structure (linked).</p>
<p class="linemarker linemarker-13">The task that inspired this module is the analysis of a volume content to
understand where to free space.</p>
<section id="how-it-works">
<h2>How it works<a class="headerlink" href="#how-it-works" title="Link to this heading">¶</a></h2>
<section id="nodes">
<h3>Nodes<a class="headerlink" href="#nodes" title="Link to this heading">¶</a></h3>
<p class="linemarker linemarker-22">Each directory/file is represented by a node containing information about the
path of the element, the node of the parent, the nodes of the children and the
properties associated to it.</p>
<p class="linemarker linemarker-26">This information are populated when creating every single node: the children
nodes are created and then the children’ children are created and so on.
The result is that all the nodes in the subtrees of the initial nodes are
computed. The initial node is the root of the tree hence it has no parent.</p>
</section>
<section id="trees">
<h3>Trees<a class="headerlink" href="#trees" title="Link to this heading">¶</a></h3>
<p class="linemarker linemarker-34">The tree class is initialized with a single node (the root) and, by default, a
set of basic properties is automatically computed, such as height, depth, number
of nodes, size of the nodes/subtrees.</p>
<p class="linemarker linemarker-38">The tree class provide the following functionalities:</p>
<ul class="simple">
<li><p class="linemarker linemarker-40">Different types of iteration on the nodes (e.g. depth-first, breadth-first)</p></li>
<li><p class="linemarker linemarker-41">Computation of different types of custom properties (e.g. bottom-up, top-down)</p></li>
<li><p class="linemarker linemarker-42">Pruning of part of the trees</p></li>
<li><p class="linemarker linemarker-43">Exporting in csv and Excel</p></li>
</ul>
</section>
<section id="properties">
<h3>Properties<a class="headerlink" href="#properties" title="Link to this heading">¶</a></h3>
<p class="linemarker linemarker-48">The basic properties of the nodes computed by default are listed in a specific
enum, its values are the key to access the properties on the node. Custom
properties can be computed as well by using the correct funciton according to
type of the property.</p>
<p class="linemarker linemarker-53">Examples of the types of properties are the following: height is bottom-up
function since it must be computed on children first and on parent later while
the depth is a top-down function since it must be computed on parent first and
on children later. In addition, there is the possibility to compute a property
that depends only on the property of a single node (no parent/children
information required).</p>
<p class="linemarker linemarker-60">The computation of a property is described by functions that contain the
operations to perform on the node to obtain the result. The process is similar
to a recursion, where there is a base case and an recursive case. For example, a
bottom-up property requires a function to compute the property on the leaves
(base case) and a function to compute the property on the inner nodes using also
the information on the children (recursive case).</p>
</section>
</section>
<section id="getting-started">
<h2>Getting started<a class="headerlink" href="#getting-started" title="Link to this heading">¶</a></h2>
<section id="tree-initialization">
<h3>Tree initialization<a class="headerlink" href="#tree-initialization" title="Link to this heading">¶</a></h3>
<p class="linemarker linemarker-73">Initialize a tree and automatically compute basic tree properties on every node.
A tree can be initialized also with a Path object or a PathNode and automatic
property computation can be turned off.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pathtreelib</span> <span class="kn">import</span> <span class="n">PathTree</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">PathTree</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="node-fields">
<h3>Node fields<a class="headerlink" href="#node-fields" title="Link to this heading">¶</a></h3>
<p class="linemarker linemarker-85">Access to the fields of a node, in particular the root. Each node exposes its
Path, the parent as PathNode, the list of children as PathNodes and a dictionary
containint its properties.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">node</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">root</span>
<span class="n">node</span><span class="o">.</span><span class="n">path</span>
<span class="n">node</span><span class="o">.</span><span class="n">parent</span>
<span class="n">node</span><span class="o">.</span><span class="n">children</span>
<span class="n">node</span><span class="o">.</span><span class="n">properties</span>
</pre></div>
</div>
</section>
<section id="iteration-on-nodes">
<h3>Iteration on nodes<a class="headerlink" href="#iteration-on-nodes" title="Link to this heading">¶</a></h3>
<p class="linemarker linemarker-100">Iterate on the nodes of the tree. It is possible to iterate in three different
ways: breadth-first (used for __iter__), depth-first and validated.
The first two ways are classic approaches, the third is custom-made and consist
in a breadth-first where subtrees that do not satisfy a validation condition are
pruned from the iteration: if the condition is not satisfied on a node, it and
its subtree are excluded from the iteration.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Breadth-first (default)</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">:</span>
   <span class="k">pass</span>
<span class="c1"># Breadth-first</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">breadth_first_iter</span><span class="p">():</span>
   <span class="k">pass</span>
<span class="c1"># Depth-first</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">depth_first_iter</span><span class="p">():</span>
   <span class="k">pass</span>
<span class="c1"># Validated iter</span>
<span class="n">validation_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">property</span><span class="p">[</span><span class="n">PathTreeProperty</span><span class="o">.</span><span class="n">DEPTH</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">5</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">validated_iter</span><span class="p">(</span><span class="n">validation_func</span><span class="p">):</span>
   <span class="k">pass</span>
</pre></div>
</div>
</section>
<section id="property-computation">
<h3>Property computation<a class="headerlink" href="#property-computation" title="Link to this heading">¶</a></h3>
<p class="linemarker linemarker-126">There are three types of properties supported:</p>
<ul class="simple">
<li><p class="linemarker linemarker-128">Bottom-up: the property is computed on the children (the leaves are the base</p></li>
</ul>
<p class="linemarker linemarker-129">case) and then on the parent (recursive case)
* Top-down: the property is computed on the parent (the root is the base case)
and then on the children (recursive case)
* Individual property: the property can be computed on the node independently
from the others</p>
<section id="bottom-up-property">
<h4>Bottom-up property<a class="headerlink" href="#bottom-up-property" title="Link to this heading">¶</a></h4>
<p class="linemarker linemarker-138">We use the height as an example. The height of the nodes is a bottom-up property
that has two cases:</p>
<ol class="arabic simple">
<li><p class="linemarker linemarker-141">If the node is a leaf, then the height is 0</p></li>
<li><p class="linemarker linemarker-142">If the node is an inode, the height is the minimum height of the children +1
(assuming the property is already computed on the children)</p></li>
</ol>
<p class="linemarker linemarker-145">The first case is expressed by a function that maps a node into an integer and
that will be applied only on leaves. The second case is expressed by a function
that maps a node and a list of nodes into an integer: the node contains an inode
while the list contains its children.</p>
<p class="linemarker linemarker-150">Note. The second case function could take as parameter only the inode since its
children are simply inode.children, however it is preferred to keep explicitly
the parameter as a remainder of how the property is computed.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">leaf_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">leaf</span><span class="p">:</span> <span class="mi">0</span>
<span class="n">inode_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">inode</span><span class="p">,</span> <span class="n">children</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">min</span><span class="p">([</span><span class="n">child</span><span class="o">.</span><span class="n">property</span><span class="p">[</span><span class="s2">&quot;height&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">])</span>
<span class="n">tree</span><span class="o">.</span><span class="n">compute_bottom_up_property</span><span class="p">(</span><span class="s2">&quot;height&quot;</span><span class="p">,</span> <span class="n">leaf_func</span><span class="o">=</span><span class="n">leaf_func</span><span class="p">,</span> <span class="n">inode_func</span><span class="o">=</span><span class="n">inode_func</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="top-down-property">
<h4>Top-down property<a class="headerlink" href="#top-down-property" title="Link to this heading">¶</a></h4>
<p class="linemarker linemarker-163">We use the depth as an example. The depth of the nodes is a top-down property
that has two cases:</p>
<ol class="arabic simple">
<li><p class="linemarker linemarker-166">If the node is the root, then the depth is 0</p></li>
<li><p class="linemarker linemarker-167">If the node has a parent, the depth is the depth of the parent +1 (assuming
the property is already computed on the parent)</p></li>
</ol>
<p class="linemarker linemarker-170">The first case is expressed by a function that maps a node into an integer and
that will be applied only on the root. The second case is expressed by a
function that maps two nodes into an integer: the nodes are a node and its
parent.</p>
<p class="linemarker linemarker-175">Note. The second case function could take as parameter only a node since its
paernt is simply node.parent, however it is preferred to keep explicitly
the parameter as a remainder of how the property is computed.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">root_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">root</span><span class="p">:</span> <span class="mi">0</span>
<span class="n">notroot_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">parent</span><span class="o">.</span><span class="n">property</span><span class="p">[</span><span class="s2">&quot;depth&quot;</span><span class="p">]</span>
<span class="n">tree</span><span class="o">.</span><span class="n">compute_dop_down_property</span><span class="p">(</span><span class="s2">&quot;depth&quot;</span><span class="p">,</span> <span class="n">root_func</span><span class="o">=</span><span class="n">root_func</span><span class="p">,</span> <span class="n">notroot_func</span><span class="o">=</span><span class="n">notroot_func</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="individual-property">
<h4>Individual property<a class="headerlink" href="#individual-property" title="Link to this heading">¶</a></h4>
<p class="linemarker linemarker-188">We use the flag is directory as an example. The property of being a directory
for a node depends exclusively on the node itself, hence in this case there is
no more than one case to manage:</p>
<ol class="arabic simple">
<li><p class="linemarker linemarker-192">If the path of the node is a directory then true, else false</p></li>
</ol>
<p class="linemarker linemarker-194">The case is expressed by a function that maps a node into a boolean and that
will be applied to each node in the tree.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">property_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">is_dir</span><span class="p">()</span>
<span class="n">tree</span><span class="o">.</span><span class="n">compute_individual_property</span><span class="p">(</span><span class="s2">&quot;is_dir&quot;</span><span class="p">,</span> <span class="n">property_func</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="pruning">
<h3>Pruning<a class="headerlink" href="#pruning" title="Link to this heading">¶</a></h3>
<p class="linemarker linemarker-205">The pruning can help reducing the time requested to navigate the tree by removing the nodes that are not considered useful. The usefulness of a node is expressed by a boolean function that evaluates true only on nodes that must be keep in the tree.
There are two modes of pruning: logical and physical.</p>
<p class="linemarker linemarker-208">As an example, we show the pruning of all nodes that have size smaller than 1 KB (1024 B).</p>
<section id="logical-pruning">
<h4>Logical pruning<a class="headerlink" href="#logical-pruning" title="Link to this heading">¶</a></h4>
<p class="linemarker linemarker-213">The logical pruning does not explicitly remove any node from the tree but set the property pruned to true if the node should be considered logically removed from the tree.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">keep_condition</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">property</span><span class="p">[</span><span class="n">PathTreeProperty</span><span class="o">.</span><span class="n">SIZE</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1024</span>
<span class="n">tree</span><span class="o">.</span><span class="n">logical_pruning</span><span class="p">(</span><span class="n">keep_condition</span><span class="o">=</span><span class="n">keep_condition</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="physical-pruning">
<h4>Physical pruning<a class="headerlink" href="#physical-pruning" title="Link to this heading">¶</a></h4>
<p class="linemarker linemarker-223">The physical pruning explicitly removes any node (and its subtree) that does not
satisfy the condition, however the property of the nodes are not recomputed.
E.g. suppose a root has height of 5, if the pruning condition removes all the
leaves, the real height of the tree becomes 4, however the value of the property
would still be 5.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">keep_condition</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">property</span><span class="p">[</span><span class="n">PathTreeProperty</span><span class="o">.</span><span class="n">SIZE</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1024</span>
<span class="n">tree</span><span class="o">.</span><span class="n">physical_pruning</span><span class="p">(</span><span class="n">keep_condition</span><span class="o">=</span><span class="n">keep_condition</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="exporting">
<h3>Exporting<a class="headerlink" href="#exporting" title="Link to this heading">¶</a></h3>
<p class="linemarker linemarker-237">The nodes can be exported in csv or Excel. Each node is mapped to a record
containing the path of the node and, by default, all its properties (the
property list is customizable). To prevent accidental huge exports the number of
nodes that can be exported is limited, by default, to a million nodes (the limit
can be changed or removed). In addition, to export only interesting rows, it is
possible to specify a condition to export only nodes that satisfy a specific
criteria.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">csvfile</span><span class="o">=</span><span class="s2">&quot;test.csv&quot;</span><span class="p">,</span> <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;heigth&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">,</span> <span class="s2">&quot;is_dir&quot;</span><span class="p">],</span> <span class="n">node_limit</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="n">to_excel</span><span class="p">(</span><span class="n">csvfile</span><span class="o">=</span><span class="s2">&quot;test.xlsx&quot;</span><span class="p">,</span> <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;heigth&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">,</span> <span class="s2">&quot;is_dir&quot;</span><span class="p">],</span> <span class="n">node_limit</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h3>
<p class="linemarker linemarker-253">Analysis of the whole C volume in Windows to find the most space consuming
folders with holiday pictures (folders with a large number of jpg files).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generate the whole tree (could take a while if the volume is large)</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">PathTree</span><span class="p">(</span><span class="s2">&quot;C:/&quot;</span><span class="p">)</span>

<span class="c1"># Compute on each node the number of picture in its subtree</span>
<span class="n">tree</span><span class="o">.</span><span class="n">compute_bottom_up_property</span><span class="p">(</span>
   <span class="s2">&quot;num_of_jpg&quot;</span><span class="p">,</span>
   <span class="n">leaf_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">leaf</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s1">&#39;.jpg&#39;</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">inode_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">inode</span><span class="p">,</span> <span class="n">children</span><span class="p">:</span> <span class="nb">sum</span><span class="p">([</span><span class="n">child</span><span class="o">.</span><span class="n">property</span><span class="p">[</span><span class="s2">&quot;num_of_jpg&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">])</span>
<span class="p">)</span>

<span class="c1"># Keep only the subtrees of interest (that have at least 10 pics)</span>
<span class="n">tree</span><span class="o">.</span><span class="n">physical_pruning</span><span class="p">(</span><span class="n">keep_condition</span><span class="o">=</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">property</span><span class="p">[</span><span class="s2">&quot;num_of_jpg&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span>

<span class="c1"># The nodes that are now leaves are the photo directories we are looking for</span>
<span class="n">tree</span><span class="o">.</span><span class="n">compute_individual_property</span><span class="p">(</span><span class="s2">&quot;photo_dir&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># Find the 3 largest photo directories</span>
<span class="n">photo_dirs</span> <span class="o">=</span> <span class="p">[</span>
   <span class="n">node</span>
   <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span>
   <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">property</span><span class="p">[</span><span class="s2">&quot;photo_dir&quot;</span><span class="p">]</span>
<span class="p">]</span>
<span class="n">photo_dirs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">property</span><span class="p">[</span><span class="n">PathTreeProperty</span><span class="o">.</span><span class="n">SIZE</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The 3 largest photo directories:&quot;</span><span class="p">,</span> <span class="n">photo_dirs</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>

<span class="c1"># Export all the photo directories with the main information to csv</span>
<span class="n">tree</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span>
   <span class="s2">&quot;large_photo_dirs&quot;</span><span class="p">,</span>
   <span class="n">properties</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;num_of_jpg&quot;</span><span class="p">,</span> <span class="n">PathTreeProperty</span><span class="o">.</span><span class="n">SIZE</span><span class="p">],</span>
   <span class="n">node_condition</span><span class="o">=</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">property</span><span class="p">[</span><span class="s2">&quot;photo_dir&quot;</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">pathtreelib</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="PathNode.html">banana</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Marco Calandro.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/getting_started.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>